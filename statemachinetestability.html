--- 
layout: documentation 
title: StateMachine 
teaser: Accelerates your state handling
navigation:
   - name: Overview
     link: statemachine.html
   - name: Tutorial
     link: statemachinetutorial.html	
   - name: Passive State Machine
     link: statemachinepassivestatemachine.html
   - name: Active State Machine
     link: statemachineactivestatemachine.html
   - name: Actions
     link: statemachineactions.html
   - name: Hierarchical Transitions
     link: statemachinehierarchicaltransitions.html
   - name: Exception Handling
     link: statemachineexceptionhandling.html
   - name: Extensions
     link: statemachineextensions.html
   - name: Events
     link: statemachineevents.html
   - name: Logging
     link: statemachinelogging.html
   - name: Reports
     link: statemachinereports.html
   - name: Persistence
     link: statemachinepersistence.html   
   - name: Testability
     link: statemachinetestability.html
   - name: Custom Types for States and Events
     link: statemachinecustomtypes.html
   - name: Complete State Machine Sample
     link: statemachinesample.html
   - name: Specifications
     link: statemachinespecifications.html
---
<h2>Testability</h2>
<p>
To test code that uses a state machine, we first replace active state machines with passive ones.
This can easily be achieved by injecting a <code>IStateMachine</code> into the class under test.
In production code an active state machine is injected, in test code, a passive state machine is used.
Passive and active state machine have exactly the same behavior but for one feature. 
Active state machines have their own worker thread. But tests are much simpler if they are pure synchronous, therefore this is a good thing for us during testing.
</p>
<p>
In production code, you should add handlers for the exception events of the state machine. 
In tests, you can use the fact that the state machine will re-throw any exception if there is no event handler registered.
This makes sure that no exceptions are swallowed in your tests.
</p>


